## JVM运行时数据区

![运行时数据区](https://gitee.com/cdx_dayshow/picBed/raw/master/img/运行时数据区.png)



### 运行时数据区域

运行时数据区域包括方法区、虚拟机栈、本地方法栈、堆、程序计数器。其中方法区和堆是所有线程共享的数据区，其他的是线程隔离的数据区。

### 程序计数器

程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器，确定下一条需要执行的字节码指令。java的多线程是通 过线程轮流切换并分配处理器执行时间的方式来实现的，在任何确定的一个时刻，一个处理器只会执行一条线程中的指令。为了线程切换之后能恢复到正确的执行位 置，每个线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响。如果线程正在执行的是一个java方法，则计数器记录的是正在执行的虚拟机字 节码指令的地址，如果正在执行的是native方法，则计数器值为空。

### java虚拟机栈

java虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是java方法执行的内存模型：每个方法被执行的时候都会创建一个栈帧用 于存在局部变量表、操作栈、动态链接、方法出口等信息。通过所说的栈是局部变量表，即与对象内存分配关系最密切的内存区域。局部变量表的内存空间在编译期 间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是确定的，在运行期不会改变。

java虚拟机栈有两种异常：如果线程请求的栈深度大于虚拟机所允许的深度，则抛弃StackOverflowError异常；如果虚拟机栈可以动态扩展的，当扩展时无法申请到足够的内存时会抛出OutOfMemoryError异常。

### 本地方法栈

本地方法栈与虚拟机栈所发挥的作用是相似的，区别在于虚拟机栈为虚拟机执行java方法的服务，本地方法栈则是为虚拟机使用到native方法服务。

### java堆

java堆是虚拟机所管理的内存中最大的一块，是虚拟机启动是创建的能被所有线程共享的一块内存区域。java堆的唯一目的就是存放对象实例，几乎 所有的对象实例和数组都在这里分配内存（随着JTI编译器的发展，在栈上也有可能分配）。java堆是垃圾收集器管理的主要区域，在物理上可以使不连续的 内存空间，但在逻辑上是联系的。

如果再堆中没有内存完成实例的分配，并且堆也无法在扩展的时候，将会抛出OutOfMemoryError异常。

### 方法区

方法区也是线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。这块区域很少进行垃圾回收，甚 至可以不实现垃圾收集，主要是针对常量池的回收和对类型的卸载。当方法区无法分配内存的时候，将抛出OutOfMemoryError异常。

Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池，用于存放编译期的各种字面量和符号引用。并非预置入 Class文件中的常量才能进入常量池，运行期间也可能将新的常量放入池中，开发中用的比较多的是String类的intern()方法。

### 举例说明

![image-20200722162448120](https://gitee.com/cdx_dayshow/picBed/raw/master/img/image-20200722162448120.png)

假设这句代码出现在方法体中，那么Object obj将会反映到java栈的局部变量表中，作为一个reference类型数据出现，new Object()将会反映到java堆中，形成一块存储了Object类型的实例数据的结构化内存，此对象类型数据，如对象类型、父类、实现的接口、方法 等信息存储在方法区。

![image-20200722173631742](https://gitee.com/cdx_dayshow/picBed/raw/master/img/image-20200722173631742.png)

运行该程序时，首先启动一个Java虚拟机进程，这个进程首先从classpath中找到AppMain.class文件，读取这个文件中的二进制数据，然后把Appmain类的类信息存放到运行时数据区的方法区中，这就是AppMain类的加载过程。

 

接着，Java虚拟机定位到方法区中AppMain类的Main()方法的字节码，开始执行它的指令。这个main()方法的第一条语句就是：

 

![img](https://gitee.com/cdx_dayshow/picBed/raw/master/img/wps7TRhqR.jpg) 

 

该语句的执行过程：

 

1、Java虚拟机到方法区找到Sample类的类型信息，没有找到，因为Sample类还没有加载到方法区（这里可以看出，java中的内部类是单独存在的，而且刚开始的时候不会跟随包含类一起被加载，等到要用的时候才被加载）。Java虚拟机立马加载Sample类，把Sample类的类型信息存放在方法区里。

 

2、Java虚拟机首先在堆区中为一个新的Sample实例分配内存, 并在Sample实例的内存中存放一个方法区中存放Sample类的类型信息的内存地址。

 

3、JVM的进程中，每个线程都会拥有一个方法调用栈，用来跟踪线程运行中一系列的方法调用过程，栈中的每一个元素就被称为栈帧，每当线程调用一个方法的时候就会向方法栈压入一个新帧。这里的帧用来存储方法的参数、局部变量和运算过程中的临时数据。

 

4、位于“=”前的Test1是一个在main()方法中定义的一个变量（一个Sample对象的引用），因此，它被会添加到了执行main()方法的主线程的JAVA方法调用栈中。而“=”将把这个test1变量指向堆区中的Sample实例。

 

5、JVM在堆区里继续创建另一个Sample实例，并在main方法的方法调用栈中添加一个Test2变量，该变量指向堆区中刚才创建的Sample新实例。

 

6、JVM依次执行它们的printName()方法。当JAVA虚拟机执行test1.printName()方法时，JAVA虚拟机根据局部变量test1持有的引用，定位到堆区中的Sample实例，再根据Sample实例持有的引用，定位到方法去中Sample类的类型信息，从而获得printName()方法的字节码，接着执行printName()方法包含的指令，开始执行。