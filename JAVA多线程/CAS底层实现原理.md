## **一、CAS（compareAndSwap）的概念**

CAS，全称Compare And Swap（比较与交换），解决多线程并行情况下使用锁造成性能损耗的一种机制。

CAS（V, A, B），V为内存地址、A为预期原值，B为新值。如果内存地址的值与预期原值相匹配，那么将该位置值更新为新值。否则，说明已经被其他线程更新，处理器不做任何操作；无论哪种情况，它都会在 CAS 指令之前返回该位置的值。而我们可以使用自旋锁，循环CAS，重新读取该变量再尝试再次修改该变量，也可以放弃操作。

![img](https://gitee.com/cdx_dayshow/picBed/raw/master/img/2020110110528171.png)

## 二、CAS（compareAndSwap）的产生

为什么需要CAS机制呢？我们先从一个错误现象谈起。我们经常使用volatile关键字修饰某一个变量，表明这个变量是全局共享的一个变量，同时具有了可见性和有序性。但是却没有原子性。比如说一个常见的操作a++。这个操作其实可以细分成三个步骤：

（1）从内存中读取a

（2）对a进行加1操作

（3）将a的值重新写入内存中

在单线程状态下这个操作没有一点问题，但是在多线程中就会出现各种各样的问题了。因为可能一个线程对a进行了加1操作，还没来得及写入内存，其他的线程就读取了旧值。造成了线程的不安全现象。

Volatile关键字可以保证线程间对于共享变量的可见性可有序性，可以防止CPU的指令重排序(DCL单例)，但是无法保证操作的原子性，所以jdk1.5之后引入CAS利用CPU原语保证线程操作的院子性。

CAS操作由处理器提供支持，是一种原语。原语是操作系统或计算机网络用语范畴。是由若干条指令组成的，用于完成一定功能的一个过程，具有不可分割性，即原语的执行必须是连续的，在执行过程中不允许被中断。如 Intel 处理器，比较并交换通过指令的 cmpxchg 系列实现。

## **三、CAS（compareAndSwap）的原理探究**

CAS的实现主要在JUC中的atomic包，我们以AtomicInteger类为例：

![img](https://gitee.com/cdx_dayshow/picBed/raw/master/img/2020110110528172.png)

通过代码追溯，可以看出JAVA中的CAS操作都是通过sun包下Unsafe类实现，而Unsafe类中的方法都是native方法，由JVM本地实现，所以最终的实现是基于C、C++在操作系统之上操作

![img](https://gitee.com/cdx_dayshow/picBed/raw/master/img/2020110110528173.png)

Unsafe类，在sun.misc包下，不属于Java标准。Unsafe类提供一系列增加Java语言能力的操作，如内存管理、操作类/对象/变量、多线程同步等

总结：根据资料查询，其实CAS底层实现根据不同的操作系统会有不同重载，CAS的实现离不开处理器的支持。

核心代码就是一条带lock 前缀的 cmpxchg 指令，即lock cmpxchg dword ptr [edx], ecx

Atomic::cmpxchg方法解析：

mp是“os::is_MP()”的返回结果，“os::is_MP()”是一个内联函数，用来判断当前系统是否为多处理器。

如果当前系统是多处理器，该函数返回1。

否则，返回0。

LOCK_IF_MP(mp)会根据mp的值来决定是否为cmpxchg指令添加lock前缀。

如果通过mp判断当前系统是多处理器（即mp值为1），则为cmpxchg指令添加lock前缀。

否则，不加lock前缀。

这是一种优化手段，认为单处理器的环境没有必要添加lock前缀，只有在多核情况下才会添加lock前缀，因为lock会导致性能下降。cmpxchg是汇编指令，作用是比较并交换操作数。

## 四、CAS机制的优缺点

4.1 优点

cas是一种乐观锁，而且是一种非阻塞的轻量级的乐观锁，什么是非阻塞式的呢？其实就是一个线程想要获得锁，对方会给一个回应表示这个锁能不能获得。在资源竞争不激烈的情况下性能高，相比synchronized重量锁，synchronized会进行比较复杂的加锁，解锁和唤醒操作。

4.2 缺点

1）循环时间长开销大，占用CPU资源

2）只能保证一个共享变量的原子操作

3）ABA问题

4.3 解决ABA问题

1）添加版本号

2）AtomicStampedReference

java并发包为了解决这个问题，提供了一个带有标记的原子引用类“AtomicStampedReference”，它可以通过控制变量值的版本来保证CAS的正确性。因此，在使用CAS前要考虑清楚“ABA”问题是否会影响程序并发的正确性，如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更高效。

## 五、CAS使用的时机

5.1 线程数较少、等待时间短可以采用自旋锁进行CAS尝试拿锁，较于synchronized高效

5.2 线程数较大、等待时间长，不建议使用自旋锁，占用CPU较高

## 六  总结

**jdk提供的CAS机制，在汇编层级，会禁止变量两侧的指令优化，然后使用cmpxchg指令比较并更新变量值(原子性)，如果是多核则使用lock锁定(缓存锁、MESI)**

