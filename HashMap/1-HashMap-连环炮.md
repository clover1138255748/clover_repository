HashMap集合简介

特点：

1-HashMap是Map接口的一个重要实现类，基于哈希表，以key-value的形式存储数据，线程不安全；
2-null可以作为键，这样的键只能有一个，可以有一个或多个键对应的值为null；
3-存取元素无序

底层数据结构：

JDK1.8之前，由数组+链表构成，数组是存储数据的主体，链表是为了解决哈希冲突而存在的；
JDK1.8以后，由数组+链表+红黑树构成，当链表长度大于阈值（默认为8），并且数组长度大于64时，链表会转化为红黑树去解决哈希冲突。
注意： 链表转化为红黑树之前会进行判断，若果阈值大于8，但是数组长度小于64，这时链表不会转化为红黑树去存储数据，而是会对数组进行扩容。

这样做的原因：

如果数组比较小，应尽量避免红黑树结构。因为红黑树结构较为复杂，红黑树又称为平衡二叉树，需要进行左旋、右旋、变色这些操作才能保证平衡。在数组容量较小的情况下，操作数组要比操作红黑树更节省时间。综上所述：为了提高性能以及减少搜索时间，在阈值大于8并且数组长度大于64的情况下链表才会转化为红黑树而存在。具体参考treeifyBin方法。



### JDK1.8对哈希算法和寻址算法的优化
map.put("张三","xxx")

1111 1111 1111 1111 1111 1010 0111 1100
0000 0000 0000 0000 1111 1111 1111 1111
1111 1111 1111 1111 0000 0101 1000 0011
将高16位移到低16位操作
然后进行一个异或
异或操作
(1,0)=1 不一样 = 1
(1,1)=0 一样 = 0
主要是讲搞16位和低16位异或操作

寻址算法
(n-1)&hash ==数组里面的一个位置
为什么用&  取模是比较吃性能的其实&和取模的效果是一样  但是性能比较好
数学问题,数组的长度会一直是2的n次方,只要他保持数组长度是2的n次方
&操作
(1,1)=1
(1,0)=0
hash算法的优化:对每个hash值,在他的低16位中,让高低16位进行了异或,让他的低16位同时保持了高低16位的特征,尽量避免一些hash值后续出现冲突,大家可能会进入数组的同一个位置


寻址算法的优化:用与运算替代取模,提升性能e



### 哈希冲突怎么解决
两个key,多个key,他们算出来的hash的值,与n-1,与运算之后,发现定位出来的数组的位置还是一样的, hash碰撞, hash冲突

解决方法:
会在这个位置挂一个链表,这个链表里面放入多个元素,让多个key-value对,同时放在数组的一个位置里
get,如果定位到数组里发现这个位置挂了一个链表,此时遍历链表,从里面找到自己的要找的那个key-value对就可以了

假设你的链表很长,可能会导致遍历链表,性能会比较差, O(n)e

优化,如果链表的长度达到了一定的长度之后,其实会把链表转换为红黑树,遍历一颗红黑树找一个元素,此时O(logn),性能会比链表高一些e

### hashMap怎么扩容
hashMap底层是一个数组,当这个数组满了之后,他就会自动进行扩容,变成一个更大的数组,让你在里面可以去放更多的元素

进行一个reHash
假设你开始只有16个位置 扩容到了32 
那就要 hash & (32-1)


判断二进制结果中是否多出一个bit的1,如果没多,那么就是原来的index,如果多了出来,那么就是index + oldCap,通过这个方式,就避免了rehash的时候,用每个hash对新数组length取模,取模性能不高,位运算的性能比较高
