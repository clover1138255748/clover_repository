## 需求分析

### 背景

磅单补单业务需求是需要一次性补单50条

因为补单逻辑是想要根据勾选的磅单来生成托运单最后生成运输记录

其中托运单因为设计到表字段分为了好几个表

![image-20200514173217059](https://gitee.com/cdx_dayshow/picBed/raw/master/img/image-20200514173217059.png)

而且最后生成的运输记录需要依赖托运单来生成一系列数据

所以接口会比较慢!然后超过20条后就会很卡顿,有时候甚至会引起事务超时然后回滚!

而且我们现在使用的是LCN事务,事务是一起提交的!当然后面用到了seata应该会好点

因为seata是本地直接先提交其他微服务如果报错了会根据数据库的前后值回滚数据.

但其实要支持50条数据的话还是会很慢!



### 解决方案1(异步补偿)

#### 1-新建补偿表

为了表的通用性

我们尽量设计的通用一点!以后有别的因为链路太长导致接口慢的都可以采用异步机制

id 主键

biz_type 方法名

notify_count(补偿次数,大于3次将不再补偿)

状态0:未解决1:已解决

方法参数(json)

gmt_create

gmt_modifiined

#### 2-新建定时任务

在一定时间内扫描该表,根据表的方法名进行一个补偿(这里用一个策略模式+简单工单模式)

对不同的方法名执行不同的策略

#### 3-唤醒机制

对于我的补单来说并不是频繁操作的!说实话一天也补不到几次单

这异步补偿只是一个方法

如果扫描的时间过长 这里设置30s (这里补单的阈值差不多在20左右)

假设你补单50条就 需要 150s 差不多要3分钟 这显然是不行的

但是你设置为10s频繁的扫描这张表显然一个资源的浪费

这里一个想法是搞一个redis 

KEY=NOTIFY_FLAG = false

每次定时任务去扫描表之前先去redis查询这个key值是否为true

当你需要异步补偿时候把数据插入到补偿表然后将redis值设置为true

然后在你补偿完毕后将值设置为false(这样比较麻烦的一点是每次补偿完都要查询一次是否还有需要补偿的如果有就不允许将值设置为false)

具体业务代码待需求评审后贴出



### 解决方案2(多线程模式)

其假设用户补单50 我们用上面方法至少要等3分钟左右

这样一个效果其实是很差的

其实为什么不利用多线程这个东西

反正业务最多50个 如果超过25个 我们就讲多出来的数据走异步数据

### 解决方案3(加长事务超时时间)

主要就是链路过长导致数据回滚

替换seata后将这个超时时间设置长一点就OK了

### 解决方案4(引入MQ)



