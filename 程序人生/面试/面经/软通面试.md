## arrayList和LinkedList区别

**从实现看**：

1. LinkedList底层实现是双链表
2. ArrayList底层实现是动态数组

**从扩容机制看**：

1. LinkedList不存在扩容 的说法，因为是链表结构。
2. ArrayList底层是动态数组存在扩容说法，默认的数组大小是10，在检测是否需要扩容后，如果扩容，会扩容为原来的1.5倍大小。原理就是把老数组的元素存储到新数组里面

**从优点看**：

1. ArrayList的查找性能好，因为底层是数组，适用于查找元素。
2. LinkedList底层是双链表，对于插入或者删除元素来说，操作方便，性能高。

**从缺点看**：

1. ArrayList因为是一块连续的内存，存储数据元素，所以如果要删除或者插入一个元素，那么之前或者之后的元素都要移动，代价很高。
2. LinkedList是链表，在内存中可以是不连续的，通过指针连接结点，如果要查找元素，必须去遍历整个链表，这样就比较麻烦。

**从安全角度看**：

1. ArrayList在单线程环境下是安全的，多线程环境下不是线程安全的，容易造成脏读的问题，如果要使ArrayList是线程安全的，那么可以选择使用Collections.synchronizedList(new ArrayList())
2. LinkedList在单线程环境下是安全的，多线程环境下不是线程安全的，容易造成脏读的问题，如果要使LinkedList是线程安全的，那么可以选择使用Collections.synchronizedList(new LinkedList())

**LinkedList和ArrayList的数据存储都是有序的，而且元素是可以重复的。**

**两者add都是将元素追加到现有集合元素的末尾**。

## CAS底层实现

JAVA多线程/CAS底层实现.md

## 类加载器一个过程

其他/JVM类加载过程.md

## 怎么用redis实现一个MQ

数据库/Redis/Redis怎么实现一个消息队列

## JVM内存模型

其他/JVM内存模型.md

## JAVA内存模型

JAVA多线程/详解Volatile关键字.md

## hashmap底层实现

JAVA基础知识/Map/HashMap源码解析.md

## 怎么保证数据原子性和可见性

Volatile+CAS

## 线程几种状态以及等待和阻塞的不同是什么

 这个状态下是指线程拥有了某个锁之后, 调用了他的wait方法, 等待其他线程/锁拥有者调用 notify / notifyAll 一遍该线程可以继续下一步操作, 这里要区分 BLOCKED 和 WATING 的区别, 一个是在临界点外面等待进入, 一个是在理解点里面wait等待别人notify, 线程调用了join方法 join了另外的线程的时候, 也会进入WAITING状态, 等待被他join的线程执行结束

1. 初始状态
   实现Runnable接口和继承Thread可以得到一个线程类，new一个实例出来，线程就进入了初始状态。

2.1. 就绪状态
就绪状态只是说你资格运行，调度程序没有挑选到你，你就永远是就绪状态。
调用线程的start()方法，此线程进入就绪状态。
当前线程sleep()方法结束，其他线程join()结束，等待用户输入完毕，某个线程拿到对象锁，这些线程也将进入就绪状态。
当前线程时间片用完了，调用当前线程的yield()方法，当前线程进入就绪状态。
锁池里的线程拿到对象锁后，进入就绪状态。
2.2. 运行中状态
线程调度程序从可运行池中选择一个线程作为当前线程时线程所处的状态。这也是线程进入运行状态的唯一一种方式。

3. 阻塞状态
   阻塞状态是线程阻塞在进入synchronized关键字修饰的方法或代码块(获取锁)时的状态。

4. 等待
   处于这种状态的线程不会被分配CPU执行时间，它们要等待被显式地唤醒，否则会处于无限期等待的状态。

5. 超时等待
   处于这种状态的线程不会被分配CPU执行时间，不过无须无限期等待被其他线程显示地唤醒，在达到一定时间后它们会自动唤醒。

6. 终止状态
   当线程的run()方法完成时，或者主线程的main()方法完成时，我们就认为它终止了。这个线程对象也许是活的，但是，它已经不是一个单独执行的线程。线程一旦终止了，就不能复生。
   在一个终止的线程上调用start()方法，会抛出java.lang.IllegalThreadStateException异常。