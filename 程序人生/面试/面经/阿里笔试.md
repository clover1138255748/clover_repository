1. 【Java】你知道哪几种垃圾收集器，各自的优缺点，重点讲下 cms，包括原理，流程，优缺点

   ```
   1.Serial/Serial Old收集器 是最基本最古老的收集器，它是一个单线程收集器，并且在它进行垃圾收集时，必须暂停所有用户线程。Serial收集器是针对新生代的收集器，采用的是**复制**算法，Serial Old收集器是针对老年代的收集器，采用的是**标记整理**算法。它的优点是实现简单高效，但是缺点是会给用户带来停顿。
   
   2.ParNew收集器 是Serial收集器的多线程版本，使用多个线程进行垃圾收集。
   
   3.Parallel Scavenge收集器 是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是**复制**算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量。
   
   4.Parallel Old收集器 是Parallel Scavenge收集器的老年代版本（并行收集器），使用多线程和**标记整理**算法。
   
   5.CMS（Current Mark Sweep）收集器 是一种以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是**标记清除**算法。
   
   6.G1收集器 是当今收集器技术发展最前沿的成果，它是一款面向服务端应用的收集器，它能充分利用多CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型。
   
   CMS 处理过程有七个步骤： 
   初始标记,会导致swt；
   
   2-并发标记，与用户线程同时运行； 
   3-预清理，与用户线程同时运行； 
   
   4-可被终止的预清理\ 与用户线程同时运行； 
   5-重新标记，会导致swt； 
   
   6-并发清除，与用户线程同时运行； 
   7-并发重置状态等待下次CMS的触发，与用户线程同时运行；
   
   缺点:CMS是基于标记-清除算法的，只会将标记为为存活的对象删除，并不会移动对象整理内存空间，会造成内存碎片
   优点:一种以获取最短回收停顿时间为目标的收集
   ```

   

1.	【设计模式】编程中自己都怎么考虑一些设计原则的，比如开闭原则，以及在工作中的应用。

```
为什么使用开闭原则
第一：开闭原则非常有名，只要是面向对象编程，在开发时都会强调开闭原则

第二：开闭原则是最基础的设计原则，其它的五个设计原则都是开闭原则的具体形态，也就是说其它的五个设计原则是指导设计的工具和方法，而开闭原则才是其精神领袖。依照java语言的称谓，开闭原则是抽象类，而其它的五个原则是具体的实现类。

第三：开闭原则可以提高复用性 
在面向对象的设计中，所有的逻辑都是从原子逻辑组合而来，不是在一个类中独立实现一个业务逻辑。只有这样的代码才可以复用，粒度越小，被复用的可能性越大。那为什么要复用呢？减少代码的重复，避免相同的逻辑分散在多个角落，减少维护人员的工作量。那怎么才能提高复用率呢？缩小逻辑粒度，直到一个逻辑不可以分为止。

第四：开闭原则可以提高维护性 
一款软件量产后，维护人员的工作不仅仅对数据进行维护，还可能要对程序进行扩展，维护人员最乐意的事是扩展一个类，而不是修改一个类。让维护人员读懂原有代码，再进行修改，是一件非常痛苦的事情，不要让他在原有的代码海洋中游荡后再修改，那是对维护人员的折磨和摧残。

第五：面向对象开发的要求 
万物皆对象，我们要把所有的事物抽象成对象，然后针对对象进行操作，但是万物皆发展变化，有变化就要有策略去应对，怎么快速应对呢？这就需要在设计之初考虑到所有可能变化的因素，然后留下接口，等待“可能”转变为“现实”。

如何使用开闭原则
第一：抽象约束 
抽象是对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放，其包含三层含义：

通过接口或抽象类约束扩散，对扩展进行边界限定，不允许出现在接口或抽象类中不存在的public方法。
参数类型，引用对象尽量使用接口或抽象类，而不是实现类，这主要是实现里氏替换原则的一个要求
抽象层尽量保持稳定，一旦确定就不要修改
第二：元数据(metadata)控件模块行为 
编程是一个很苦很累的活，那怎么才能减轻压力呢？答案是尽量使用元数据来控制程序的行为，减少重复开发。什么是元数据？用来描述环境和数据的数据，通俗的说就是配置参数，参数可以从文件中获得，也可以从数据库中获得。

第三：制定项目章程 
在一个团队中，建立项目章程是非常重要的，因为章程是所有人员都必须遵守的约定，对项目来说，约定优于配置。这比通过接口或抽象类进行约束效率更高，而扩展性一点也没有减少。

第四：封装变化 
对变化封装包含两层含义： 
(1)将相同的变化封装到一个接口或抽象类中 
(2)将不同的变化封装到不同的接口或抽象类中，不应该有两个不同的变化出现在同一个接口或抽象类中。 
封装变化，也就是受保护的变化，找出预计有变化或不稳定的点，我们为这些变化点创建稳定的接口。
　　
举个栗子
还是那个策略模式
付钱的方式有很多种 
如果每次新增一种付钱模式就要修改一次方法的话对代码的一个稳定是一个很不好的体验
如果每次增加一种付钱模式就加一个类策略的话就符合开闭原则
```



1. 【算法】写一段代码，模拟一个10000个1-10000的随机数，并采用归并排序对其进行排序

   

   	Random random = new Random(); 
   	
   	List<Intege> list = new ArrayList<Intege>(10000);
   			Integer[] nsz=new Integer[list.size()];
   	     for(int i=0;i<10000;i++) {   
   	       int randint =(int)Math.floor((random.nextDouble()*100000.0));  //产生0-10000之间随机数  
   	       list.add(randint);
   				}
   		int[] data = list.toArray(nsz);
   		mergeSort(data);
   	public static void mergeSort(int[] data) {
   			sort(data, 0, data.length - 1);
   		}
   	
   	public static void sort(int[] data, int left, int right) {
   		if (left >= right)
   			return;
   		// 找出中间索引
   		int center = (left + right) / 2;
   		// 对左边数组进行递归
   		sort(data, left, center);
   		// 对右边数组进行递归
   		sort(data, center + 1, right);
   		// 合并
   		merge(data, left, center, right);
   		print(data);
   	}
   	 
   	/**
   	 * 将两个数组进行归并，归并前面2个数组已有序，归并后依然有序
   	 * 
   	 * @param data
   	 *            数组对象
   	 * @param left
   	 *            左数组的第一个元素的索引
   	 * @param center
   	 *            左数组的最后一个元素的索引，center+1是右数组第一个元素的索引
   	 * @param right
   	 *            右数组最后一个元素的索引
   	 */
   	public static void merge(int[] data, int left, int center, int right) {
   		// 临时数组
   		int[] tmpArr = new int[data.length];
   		// 右数组第一个元素索引
   		int mid = center + 1;
   		// third 记录临时数组的索引
   		int third = left;
   		// 缓存左数组第一个元素的索引
   		int tmp = left;
   		while (left <= center && mid <= right) {
   			// 从两个数组中取出最小的放入临时数组
   			if (data[left] <= data[mid]) {
   				tmpArr[third++] = data[left++];
   			} else {
   				tmpArr[third++] = data[mid++];
   			}
   		}
   		// 剩余部分依次放入临时数组（实际上两个while只会执行其中一个）
   		while (mid <= right) {
   			tmpArr[third++] = data[mid++];
   		}
   		while (left <= center) {
   			tmpArr[third++] = data[left++];
   		}
   		// 将临时数组中的内容拷贝回原数组中
   		// （原left-right范围的内容被复制回原数组）
   		while (tmp <= right) {
   			data[tmp] = tmpArr[tmp++];
   		}
   	}




1.	【框架】简单介绍连接池的优点和原理? 

```
数据库连接是非常宝贵的系统资源，连接一次数据库，底层程序需要经过很多步骤，花费比较多的时间，如果每次要操作数据库的时候才开始建立数据库连接，用完之后再关闭连接，势必造成程序的效率问题。
连接池的基本原理是，先初始化一定的数据库连接对象，并且把这些连接保存在连接池中。当程序需要访问数据库的时候，从连接池中取出一个连接，数据库操作结束后，再把这个用完的连接重新放回连接池。
当然以上我说的是只是一个最简单的工作原理，连接池本身是比较复杂的，里面涉及到并发的控制，连接的提取，回收算法，连接不够时的相应等等。
```

1.	【操作系统】Linux 系统下你关注过哪些内核参数，说说你知道的

```
#启用syncookies
net.ipv4.tcp_max_syn_backlog = 8192
#SYN队列长度
net.ipv4.tcp_synack_retries=2
#SYN ACK重试次数
net.ipv4.tcp_fin_timeout = 30
#主动关闭方FIN-WAIT-2超时时间
net.ipv4.tcp_keepalive_time = 1200
#TCP发送keepalive消息的频度
net.ipv4.tcp_tw_reuse = 1
#开启TIME-WAIT重用
net.ipv4.tcp_tw_recycle = 1
#开启TIME-WAIT快速回收
net.ipv4.ip_local_port_range = 1024 65000
#向外连接的端口范围
net.ipv4.tcp_max_tw_buckets = 5000
#最大TIME-WAIT数量，超过立即清除
net.ipv4.tcp_syn_retries = 2
```



1. 【线程并发】假如有一个第三方接口，有很多个线程去调用获取数据，现在规定每秒钟最多有 10 个线程同时调用它，如何做到。

   ```
   public ScheduledThreadPoolExecutor(int corePoolSize,
   ThreadFactory threadFactory) {
   super(corePoolSize, Integer.MAX_VALUE, 0, TimeUnit.NANOSECONDS,
   new DelayedWorkQueue(), threadFactory);
   }
   ```

1. 【框架】Mybatis 的底层实现原理。

   ```
   MyBatis工作流程
   传统工作模式：
   1-创建SqlSessionFactoryBuilder对象，调用build(inputstream)方法读取并解析配置文件，返回SqlSessionFactory对象
   2-由SqlSessionFactory创建SqlSession 对象，没有手动设置的话事务默认开启
   3-调用SqlSession中的api，传入Statement Id和参数，内部进行复杂的处理，最后调用jdbc执行SQL语句，封装结果返回。
   使用Mapper接口：
   4-前三步都相同
   5-不再调用SqlSession 的api，而是获得了接口对象，调用接口中的方法。
   
   
   ```

   

2. 【网络】TCP/IP 如何保证可靠性，说说 TCP 头的结构。

```
保证可靠性:
1、将数据截断为合理的长度;
2、超时重发;
3、对于收到的请求，给出确认响应;
4、 校验出包有错，丢弃报文段，不给出响应，TCP发送数据端，超时时会重发数据;
5、对失序数据进行重新排序，然后才交给应用层;
6、对于重复数据，能够丢弃重复数据;
7、TCP可以进行流量控制，防止较快主机致使较慢主机的缓冲区溢出;


TCP固定头部结构：

16位端口号：包括了源端口号和目的端口号。进行TCP通信时，客户端通常使用系统自动选择的临时端口号(一般都很大)，而服务器则使用知服务端口号或服务器管理员自定义的端口号。
32位序号：一次TCP通信过程中对一个传输方向上的字节流的每个字节的编号(从这个方向第一个报文段依次排列)。假设主机A和主机B进行TCP通信，A发送给B的第一个TCP报文段中的序号值是系统初始化的一个随机值ISN(初始序号值)。那么之后在A到B的方向上发送的TCP报文段中的序号值将会被系统设置为ISN加上该报文段所携带数据的第一个字节在整个数据字节流中的偏移。
32位确认号：用作对另一方发送来的TCP报文段做出相应。其值是收到对方的报文段的序号值加1。
4位头部长度：标识该TCP头部有多少个32bit字(4字节)。一共有4位，所以最大能表示TCP头部大小为60字节。
6位标志位包含如下几项：
（1）URG标志，表示紧急指针是否有效。
（2）ACK标志，表示确认号是否有效。一般称携带ACK标志的报文段是确认报文段。
（3）PSH标志，提示接收端应用程序立即从TCP接受缓冲区读走数据。
（4）RST标志，表示要求对方重新建立连接。称携带RST标志的TCP报文段为复位报文段。
（5）SYN标志，表示请求建立一个连接。称携带SYN标志的TCP报文段为同步报文段。
（6）FIN标志，表示通知对方本端将关闭连接。称携带FIN标志的TCP报文段为结束报文段。
16位窗口大小：是TCP流量控制的一个手段。这里说的窗口指的是接收通告窗口(RWND)。它告诉对方本端TCP接收缓冲区还能容纳多少字节的数据，以让对方控制发送数据的速度。
16位校验和：由发送端填充，接收端对TCP报文段执行CRC算法以效验TCP报文段在传输过程中是否损坏(包括TCP头部和数据部分)。这也是TCP可靠传输的一个重要保障。
16位紧急指针：是一个正的偏移量。它和序号字段的值相加表示最后一个紧急数据的下一字节的序号。即这个字段是紧急指针相对当前序号的偏移，为紧急偏移。以让接收端迅速接受到紧急数据。TCP的紧急指针是发送端向接收端发送紧急数据的方法。
```



1.	【架构】设计一个秒杀系统，30 分钟没付款就自动关闭交易。

```
前端:
静态资源缓存：将活动页面上的所有可以静态的元素全部静态化，尽量减少动态元素；通过CDN缓存静态资源，来抗峰值。 
禁止重复提交：用户提交之后按钮置灰，禁止重复提交 
用户限流：在某一时间段内只允许用户提交一次请求，比如可以采取IP限流
后端:
可利用负载均衡（例如反响代理Nginx等）使用多个服务器并发处理请求，减小服务器压力。
限制同一UserID访问频率：尽量拦截浏览器请求，但针对某些恶意攻击或其它插件，在服务端控制层需要针对同一个访问uid，限制访问频率。
当用户量非常大的时候，拦截流量后的请求访问量还是非常大，此时仍需进一步优化。
1.业务分离:将秒杀业务系统和其他业务分离，单独放在高配服务器上，可以集中资源对访问请求抗压。

2.采用消息队列缓存请求：将大流量请求写到消息队列缓存，利用服务器根据自己的处理能力主动到消息缓存队列中抓取任务处理请求，数据库层订阅消息减库存，减库存成功的请求返回秒杀成功，失败的返回秒杀结束。

3.利用缓存应对读请求：对于读多写少业务，大部分请求是查询请求，所以可以读写分离，利用缓存分担数据库压力。

4.利用缓存应对写请求：缓存也是可以应对写请求的，可把数据库中的库存数据转移到Redis缓存中，所有减库存操作都在Redis中进行，然后再通过后台进程把Redis中的用户秒杀请求同步到数据库中。


30分钟后关闭交易
（1）用户支付完成以后，把订单ID插入到内存的一个DelayQueue中，同时插入到Redis中。

（2）30分钟之内，用户点击了付款，则从DelayQueue中删除，从Redis中删除。

（3）超过30分钟，DelayQueue中的订单ID出队，查询数据库，改状态为自动收货，删除redis。

（4）如果30分钟之内，web服务器重启过，则web服务器启动以后，从redis中读取待收货的订单，插入到DelayQueue。


```





1.	【分布式架构】Dubbo 的原理，数据怎么流转的，怎么实现集群，负载均衡，服务注册和发现。重试转发，快速失败的策略是怎样的。

```
1-服务提供方发布服务到服务注册中心；
2-服务消费方从服务注册中心订阅服务；
3-服务消费方调用已经注册的可用服务；
4-多机器选择通过负载均衡选择一台机器
5-选择一种协议(dubbo协议)
6-请求封装成request
7-序列号
8-netty发送请求
9-服务提供者监听请求 
10-请求反序列化
11-解析request
12-选择协议解析请求
13-接口调用


Dubbo实现集群
多机部署  将自己注册到zk上
Dubbo负载均衡
Dubbo实现负载均衡，一般是对服务的提供者来实现。我们的集群管理，也就是负载均衡，然后服务的消费者在请求消费的时候，通过一定的算法进行寻址（权重）
Dubbo服务注册和发现
配置文件
Dubbo重试转发

Dubbo快速失败
FailfastClusterInvoker 只会进行一次调用，失败后立即抛出异常。适用于幂等操作，比如新增记录。
```

