[TOC]

### 索引的目的与原理

在日常生活中，经常有这样的场景：有一个没见到过的英文单词，我们查字典找到这个单词的意思；我们要出去旅行，查询到具体地点的航班号；诸如此类。在这样的场景中，我们都是通过不断的缩小范围来筛选出最终预期的结果，同时把随机的事件变成顺序事件：查询字典，比如查单词mysql，我们是按照一个字母一个字母的顺序来查询的；查询航班号，我们也是通过地点机场航空公司一个一个来筛选缩小范围的。我们总是通过同一种查找方式来锁定数据。

数据库也是一样，但显然要比现实生活中的场景要复杂得多，因为不仅会有等值查询（=），还有范围查询（>，<，BETWEEN，IN）、模糊查询（LIKE）、交集查询（AND）、并集查询（OR）等等。数据库应该选择什么样的方式来应对所有的问题呢？我们使用查字典的例子，能不能把数据分段呢？比如，如果有1000条数据，1到100分成第一段，101到200分成第二段...这样，如果要查询第328条数据，只要找第三段就可以了，这样就省去了90%的无效数据。但是，如果数据量达到100亿，要分成多少段呢？学过数据结构的童鞋知道，在数据结构中，有一种数据结构是树（Tree），树里面有一种树叫二叉搜索树（Binary Search Tree），平均复杂度是O(logN)，具有不错的查询性能。但是在这里，我们忽略了一个关键的问题，复杂度模型是基于每次相同的操作成本来考虑的，数据库的实现比较复杂，数据保存在磁盘上，而为了提高性能，每次又可以把部分数据读入内存来计算，因为我们知道——磁盘访问的成本大概是内存访问成本的十万倍左右，所以简单的搜索树，难以满足复杂的应用场景。

**索引做了些什么可以让我们查询加快速度呢？其实就是将无序的数据变成有序(相对)：**

### 索引的数据结构

上面讲了索引的基本原理，数据库的复杂性，以及操作系统的一些内容，目的就是让大家了解到，任何一种数据结构都不是凭空产生的，一定有它的背景和使用场景。那么，我们需要这些数据结构能够做什么呢？其实很简单，就是：每次查找数据的时候，把磁盘I/O次数限制在一个很小的数量级，最好是一个常量数量级。那么我们就想到，如果一个高度可控的多路搜索树，是否能够满足需求呢？在这样的背景下，B+树应运而生。

![img](https://gitee.com/cdx_dayshow/picBed/raw/master/img/20160620140312586.jpeg)

#### 详解B+树

如上图，是一棵B+树。B+树的定义，童鞋可以自行百度，我们只说一些重点。图中浅蓝色的块，我们称之为一个磁盘，可以看到，每个磁盘块包含几个数据项（深蓝色）和指针（黄色）。如：磁盘块1包含数据17和数据35，包含指针P1,P2,P3，P1指向数据小于17的磁盘块，P2指向数据在17到35之间的数据所在磁盘块，P3指向数据大于35的数据所在的磁盘块。真实数据存在于叶子节点，即3，5，9，10，13，15，28，29，36，60，75，79，90，99 。 非叶子节点不存储真实数据，只存储指引搜索方向的数据项，如17、35并不真实存在于数据表中。



#### B+树的查找过程

还是使用上面的B+树。假设，我们要查找数据项29，那么我们首先会把磁盘块1由磁盘加载到内存中，此时进行了一次I/O，在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存计算时间由于非常短（对比于I/O）可以忽略不计，通过磁盘块1的P2指针的磁盘地址指向磁盘块3，由磁盘加载到内存，此时进行了第二次I/O，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘块8到内存，此时进行了第三次I/O，同时内存中计算二分查找找到29，查询结束。这一过程，一共进行了3次I/O。在真实使用场景中，三层的B+树可以表示上百万的数据，如果上百万的数据查询只需要三次I/O，性能提高将会是巨大的。B+树就是一种索引数据结构，如果没有这样的索引，每个数据项发生一次I/O，那么成本将会大大提升。

#### B+树的性质

在上面的查找例子中，我们可以分析出一些B+树的性质：

1，I/O的次数取决于B+树的高度H，假设当前数据表的数据为N，每个磁盘块的数据项的数量是M，则有：H=log(M+1)N，当数据量N一定的情况下，M越大，H越小；而M=磁盘块大小/数据项大小，磁盘块大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度也就越低。这也就是为什么每个数据项，即索引字段要尽量的小，比如int占4个字节，要比bigint的8个字节小一半。这也是为什么B+树要求把真实数据放在叶子节点内而不是内层节点内，一旦放到内层节点内，磁盘块的数据项会大幅度的下降，导致树层级的增高。当数据项为1时，B+树会退化成线性表。

2，B+树的数据项是复合性数据结构，比如（name，age，gender）的时候，B+树是按照从左到右的顺序来建立搜索树的，比如当（小张，22，女）这样的数据来检索的时候，B+树会优先比较name来确定下一步的搜索方向，如果name相同再依次比较age和gender，最后得到检索的数据。但是，当（22，女）这样没有name的数据来的时候，B+树就不知道下一步该查哪个节点，因为建立搜索树的时候，name就是第一个比较因子，必须根据name来搜索才知道下一步去哪里查询。比如，当（小张，男）这样的数据来检索时，B+树就可以根据name来指定搜索方向，但下一字段age缺失，所以只能把名字是“小张”的所有数据都找到，然后再匹配性别是“男”的数据了。这个是非常重要的一条性质，即索引的最左匹配特性。

##### 什么是最左前缀原则？

MySQL中的索引可以以一定顺序引用多列，这种索引叫作联合索引。如User表的name和city加联合索引就是(name,city)，而最左前缀原则指的是，如果查询的时候查询条件精确匹配索引的左边连续一列或几列，则此列就可以被用到。如下：

```
select * from user where name=xx and city=xx ; ／／可以命中索引
select * from user where name=xx ; // 可以命中索引
select * from user where city=xx ; // 无法命中索引            
复制代码
```

这里需要注意的是，查询的时候如果两个条件都用上了，但是顺序不同，如 `city= xx and name ＝xx`，那么现在的查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。

由于最左前缀原则，在创建联合索引时，索引字段的顺序需要考虑字段值去重之后的个数，较多的放前面。ORDER BY子句也遵循此规则。

##### 注意避免冗余索引

冗余索引指的是索引的功能相同，能够命中就肯定能命中 ，那么 就是冗余索引如（name,city ）和（name ）这两个索引就是冗余索引，能够命中后者的查询肯定是能够命中前者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

MySQLS.7 版本后，可以通过查询 sys 库的 `schema_redundant_indexes` 表来查看冗余索引




### 索引的类型

在MySQL中，索引分为两大类：聚簇索引和非聚簇索引。聚簇索引是按照数据存放的物理位置为顺序的，而非聚簇索引则不同；聚簇索引能够提高多行检索的速度，而非聚簇索引则对单行的检索速度很快。

在这两大类的索引类型下，还可以将索引分成四个小类：

1，普通索引：最基本的索引，没有任何限制，是我们大多数情况下使用到的索引。

2，唯一索引：与普通索引类型，不同的是唯一索引的列值必须唯一，但允许为空值。

3，全文索引：全文索引（FULLTEXT）仅可以适用于MyISAM引擎的数据表；作用于CHAR、VARCHAR、TEXT数据类型的列。

4，组合索引：将几个列作为一条索引进行检索，使用最左匹配原则。

### 建立索引的原则

我们回头来看一开始提到的慢查询，当我们了解完索引原理之后，对慢查询的优化应该有一些想法，这里我们先总结一下建立索引的一些原则：

1，最左前缀匹配原则。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询（>,<,BETWEEN,LIKE）就停止匹配，比如： a = 1 AND b = 2 AND c > 3 AND d = 4，如果建立 （a,b,c,d）顺序的索引，d是用不到索引的，如果建立（a,b,d,c）的索引，则都可以用到，a,b,d的顺序可以任意调整。

2，等于（=）和in 可以乱序。比如，a = 1 AND b = 2 AND c = 3 建立（a,b,c）索引可以任意顺序，MySQL的查询优化器会帮你优化成索引可以识别的模式。

3，尽量选择区分度高的列作为索引，区分度的公式是 COUNT(DISTINCT col) / COUNT(*)。表示字段不重复的比率，比率越大我们扫描的记录数就越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度是0。可能有人会问，这个比率有什么经验么？使用场景不同，这个值也很难确定，一般需要JOIN的字段我们要求在0.1以上，即平均1条扫描10条记录。

4，索引列不能参与计算，尽量保持列“干净”。比如，FROM_UNIXTIME(create_time) = '2016-06-06' 就不能使用索引，原因很简单，B+树中存储的都是数据表中的字段值，但是进行检索时，需要把所有元素都应用函数才能比较，显然这样的代价太大。所以语句要写成 ： create_time = UNIX_TIMESTAMP('2016-06-06')。

5，尽可能的扩展索引，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。

6，单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，MySQL只能使用一个索引，会从多个单列索引中选择一个限制最为严格的索引。



```
SELECT 
count(*) AS count 
FROM trade_bASe AS a
WHERE 
a.trade_status = 7 
AND a.create_time BETWEEN '2015-09-01' AND '2016-01-14' 
AND a.booking_source = '2'

```

根据这条SQL，应该建立的索引是：trade_status, booking_source,create_time的联合索引；其中，trade_status、booking_source的顺序可以颠倒，而且 create_time 的区间查询放到后面。这就是利用了索引的最左匹配原则。

### 慢查询的优化步骤

1，查看运行效果，是否真的很慢，主要设置SQL_NO_CACHE。

2，WHERE条件单表查询，锁定最小返回记录表。这句话的意思是，把查询语句的WHERE都应用到表中返回的记录数最小的表开始查起，单表每个字段分别查询，看哪个字段的区分度最高

3，EXPLAIN查看执行计划，是否与1预期一致（从锁定记录较少的表开始查询）

4，ORDER BY LIMIT 形式的SQL语句，让排序的表优先查

5，多去了解业务的使用场景

6，加索引时，要参照建立索引的几大原则

7，观察结果，不符合预期，则重新从1开始分析。

### 索引的优化方法

1，何时使用聚簇索引或非聚簇索引：

| 使用动作描述       | 使用聚簇索引 | 使用非聚簇索引 |
| ------------------ | ------------ | -------------- |
| 列经常被分组排序   | √            | √              |
| 返回某范围内的数据 | √            | ×              |
| 一个或极少不同的值 | ×            | ×              |
| 小数目不同的值     | √            |                |
| 大数目不同的值     | ×            | √              |
| 频繁更新的列       | ×            | √              |
| 外键列             | √            | √              |
| 主键列             | √            | √              |
| 频繁修改索引列     | ×            | √              |

2，索引不会包含有NULL值的列：只要列中包含有NULL值，都将不会被包含在索引中，组合索引中只要有一列有NULL值，那么这一列对于此条组合索引就是无效的。所以我们在数据库设计时，不要让索引字段的默认值为NULL。

3，使用短索引：假设，如果有一个数据类型为CHAR(255)的列，在前10个或20个字符内，绝大部分数据的值是唯一的，那么就不要对整个列进行索引。短索引不仅可以提高查询速度而且可以节省I/O操作。

4，索引列排序：MySQL查询只使用一个索引，因此如果WHERE子句中已经使用了索引的话，那么ORDER BY中的列是不会使用索引的。因此数据库默认排序可以符合要求的情况下，不要使用排序操作；尽量不要包含多个列的排序，如果需要，最好给这些列也创建组合索引。

5，LIKE语句操作：一般情况下，不建议使用LIKE操作；如果非使用不可，如何使用也是一个研究的课题。LIKE "%aaaaa%"不会使用索引，但是LIKE "aaa%"却可以使用索引。

6，不要在索引列上进行运算：在建立索引的原则中，提到了索引列不能进行运算，这里就不再赘述了。

7,   尽量选择**区分度高的列作为索引**，区分度的公式是 `COUNT(DISTINCT col) / COUNT(*)`。表示字段不重复的比率，比率越大我们扫描的记录数就越少。

8,   尽可能的**扩展索引**，不要新建立索引。比如表中已经有了a的索引，现在要加（a,b）的索引，那么只需要修改原来的索引即可。

9,   单个多列组合索引和多个单列索引的检索查询效果不同，因为在执行SQL时，**MySQL只能使用一个索引**，会从多个单列索引中选择一个限制最为严格的索引。

10,   **最左前缀匹配原则**。这是非常重要、非常重要、非常重要（重要的事情说三遍）的原则，MySQL会一直向右匹配直到遇到范围查询`（>,<,BETWEEN,LIKE）`就停止匹配。

### 索引的缺点:降低增删改的速度

B+树是**平衡树**的一种。

> 平衡树：它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

如果一棵普通的树在**极端**的情况下，是能**退化成链表**的(树的优点就不复存在了)

![img](https://gitee.com/cdx_dayshow/picBed/raw/master/img/164c6d7a56110d4d.jpeg)

B+树是平衡树的一种，是不会退化成链表的，树的高度都是相对比较低的(基本符合**矮矮胖胖(均衡)的结构**)【这样一来我们检索的时间复杂度就是O(logn)】！从上一节的图我们也可以看见，建立索引实际上就是建立一颗B+树。

- B+树是一颗平衡树，如果我们对这颗树增删改的话，那肯定会**破坏它的原有结构**。
- **要维持平衡树，就必须做额外的工作**。正因为这些额外的工作**开销**，导致索引会降低增删改的速度

### Mysql如何为表字段添加索引？

1.添加PRIMARY KEY（主键索引）

```
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 
复制代码
```

2.添加UNIQUE(唯一索引)

```
ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 
复制代码
```

3.添加INDEX(普通索引)

```
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
复制代码
```

4.添加FULLTEXT(全文索引)

```
ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 
复制代码
```

5.添加多列索引

```
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```


